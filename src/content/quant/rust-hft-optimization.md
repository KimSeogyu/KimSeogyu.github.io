---
title: "Rust ê¸°ë°˜ HFT ì‹œìŠ¤í…œì˜ ê·¹í•œ ìµœì í™”: ìë£Œêµ¬ì¡°ì™€ í•˜ë“œì›¨ì–´ì˜ ëŒ€í™”"
date: "2026-01-14"
category: Quant
description: "ì´ë¡ ì ì¸ Big-O í‘œê¸°ë²•ì´ ì‹¤ì „ HFT(High-Frequency Trading) ì‹œìŠ¤í…œì—ì„œëŠ” ì–´ë–»ê²Œ ë¬´ë„ˆì§€ëŠ”ê°€? Rustì™€ Computer Architectureë¥¼ í™œìš©í•´ 146ë°°ì˜ ì„±ëŠ¥ í–¥ìƒì„ ì´ë¤„ë‚¸ ê¸°ìˆ ì  ì—¬ì •ì„ ê³µìœ í•©ë‹ˆë‹¤."
tags: ["rust", "hft", "performance", "systems-programming", "architecture"]
---

# ğŸ“‚ Technical Briefing: Ultra-Low Latency Orderbook Optimization

> "ì•Œê³ ë¦¬ì¦˜(BTree)ì´ ìˆ˜í•™ì ìœ¼ë¡œëŠ” ë” íš¨ìœ¨ì ì¼ì§€ë¼ë„, ë¬¼ë¦¬ì  í•˜ë“œì›¨ì–´(Real Hardware) ì•ì—ì„œëŠ” ë°°ì—´(Ring Buffer)ë³´ë‹¤ 146ë°° ëŠë¦´ ìˆ˜ ìˆë‹¤."

ê¸ˆìœµ íŠ¸ë ˆì´ë”© ì‹œìŠ¤í…œ, ê·¸ì¤‘ì—ì„œë„ **HFT(High-Frequency Trading)** ì˜ì—­ì€ ì»´í“¨í„° ê³µí•™ì˜ ì´ë¡ ì´ í•˜ë“œì›¨ì–´ì˜ ë¬¼ë¦¬ì  í•œê³„ì™€ ì •ë©´ìœ¼ë¡œ ì¶©ëŒí•˜ëŠ” ìµœì „ì„ ì…ë‹ˆë‹¤.

ì´ ê¸€ì—ì„œëŠ” êµê³¼ì„œì ì¸ ìë£Œêµ¬ì¡° ì´ë¡ ì´ ì™œ ì‹¤ì „ì—ì„œëŠ” í†µí•˜ì§€ ì•ŠëŠ”ì§€, ê·¸ë¦¬ê³  **Computer Architecture(ì»´í“¨í„° êµ¬ì¡°)**ì™€ **Rustì˜ Low-level ì œì–´**ë¥¼ í†µí•´ ì–´ë–»ê²Œ ë§ˆì´í¬ë¡œì´ˆ(Âµs)ë¥¼ ë„˜ì–´ **ë‚˜ë…¸ì´ˆ(ns)** ë‹¨ìœ„ì˜ ë ˆì´í„´ì‹œë¥¼ ë‹¬ì„±í–ˆëŠ”ì§€, ê·¸ ì‹¬ì¸µì ì¸ ë¶„ì„ ë‚´ìš©ì„ ê³µìœ í•©ë‹ˆë‹¤.

---

## 1. ê°œìš” ë° ë¬¸ì œ ì •ì˜ (Context)

ìš°ë¦¬ì˜ ëª©í‘œëŠ” ë‹¨ìˆœí–ˆìŠµë‹ˆë‹¤. **'ê°€ì¥ ë¹ ë¥¸ í˜¸ê°€ì°½(Orderbook)ì„ ë§Œë“¤ì.'**

ì¼ë°˜ì ì¸ CS ì „ê³µ ì„œì ì—ì„œëŠ” ì •ë ¬ëœ ë°ì´í„°ì˜ ê²€ìƒ‰ê³¼ ì‚½ì…ì„ ìœ„í•´ `B-Tree`ë‚˜ `Red-Black Tree`ë¥¼ ì¶”ì²œí•©ë‹ˆë‹¤. $O(\log N)$ì˜ ì‹œê°„ ë³µì¡ë„ë¥¼ ê°€ì§€ë¯€ë¡œ ìˆ˜í•™ì ìœ¼ë¡œ ë§¤ìš° íš¨ìœ¨ì ì…ë‹ˆë‹¤. ë°˜ë©´, ë°°ì—´ ê¸°ë°˜ì˜ ì ‘ê·¼ì€ ì‚½ì…/ì‚­ì œ ì‹œ $O(N)$ì´ ê±¸ë¦¬ë¯€ë¡œ ë¹„íš¨ìœ¨ì ì´ë¼ê³  ë°°ì›ë‹ˆë‹¤.

í•˜ì§€ë§Œ ì‹¤ì œ ë²¤ì¹˜ë§ˆí¬ ê²°ê³¼ëŠ” ì¶©ê²©ì ì´ì—ˆìŠµë‹ˆë‹¤.

| Data Structure | Update Time (10k ops) | Latency per Op | Speedup | Cache Locality |
| --- | --- | --- | --- | --- |
| **BTreeMap (Standard)** | ~578 Âµs | 57.8 ns | 1.0x (Baseline) | **Bad** (Pointer Chasing) |
| **Direct Indexing** | ~10.47 Âµs | 1.05 ns | 50x | **Medium** (Sparse Access) |
| **Ring Buffer (L1 Opt)** | **~3.50 Âµs** | **0.35 ns** | **146x** | **Extreme** (Contiguous) |

ì´ë¡ ì ìœ¼ë¡œ ë” ëŠë ¤ì•¼ í•  ë°°ì—´(Ring Buffer)ì´, í‘œì¤€ BTreeMapë³´ë‹¤ **146ë°°** ë¹¨ëìŠµë‹ˆë‹¤. ë„ëŒ€ì²´ ì™œ ì´ëŸ° ì¼ì´ ë²Œì–´ì§„ ê±¸ê¹Œìš”?

> **Insight:** ì•Œê³ ë¦¬ì¦˜ ë³µì¡ë„($O$)ëŠ” **'ëª¨ë“  ë©”ëª¨ë¦¬ ì ‘ê·¼ ë¹„ìš©ì´ ë™ì¼í•˜ë‹¤(0)'**ëŠ” ì˜ëª»ëœ ê°€ì • ìœ„ì—ì„œë§Œ ìœ íš¨í•©ë‹ˆë‹¤. í˜„ëŒ€ CPUì—ì„œ ë©”ëª¨ë¦¬ ì ‘ê·¼ì€ ê°€ì¥ ë¹„ì‹¼ ì—°ì‚°ì…ë‹ˆë‹¤.

---

## 2. í•µì‹¬ ê¸°ìˆ  ë¶„ì„: Why Big-O Lies?

ì´ í˜„ìƒì„ ì´í•´í•˜ê¸° ìœ„í•´ì„œëŠ” ì†Œí”„íŠ¸ì›¨ì–´ê°€ ì•„ë‹Œ **í•˜ë“œì›¨ì–´**, ì¦‰ "Memory Hierarchy"ë¥¼ ë“¤ì—¬ë‹¤ë´ì•¼ í•©ë‹ˆë‹¤.

### 2.1. The Memory Wall & Latency Numbers

CPUì˜ í´ëŸ­ ì†ë„ëŠ” ë¹„ì•½ì ìœ¼ë¡œ ë°œì „í–ˆì§€ë§Œ, ë©”ëª¨ë¦¬(DRAM)ì˜ ì ‘ê·¼ ì†ë„ëŠ” ê·¸ì— ë¯¸ì¹˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ì´ ê²©ì°¨ë¥¼ **Memory Wall**ì´ë¼ ë¶€ë¦…ë‹ˆë‹¤.

* **L1 Cache Reference:** ~0.5 ns (CPU ì½”ì–´ ë°”ë¡œ ì˜†)
* **L2 Cache Reference:** ~2.8 ns
* **Main Memory (RAM) Reference:** ~100 ns (L1ë³´ë‹¤ ì•½ 200ë°° ëŠë¦¼)

**BTreeMapì˜ íŒ¨ë°° ì›ì¸**ì´ ì—¬ê¸°ì— ìˆìŠµë‹ˆë‹¤. íŠ¸ë¦¬ëŠ” 'í¬ì¸í„°'ë¡œ ì—°ê²°ëœ êµ¬ì¡°ì…ë‹ˆë‹¤. ë¶€ëª¨ ë…¸ë“œì—ì„œ ìì‹ ë…¸ë“œë¡œ ì´ë™í•  ë•Œë§ˆë‹¤, RAMì˜ ì„ì˜ ì£¼ì†Œë¡œ ì í”„(Pointer Chasing)ë¥¼ í•´ì•¼ í•©ë‹ˆë‹¤. ì´ë•Œë§ˆë‹¤ CPUëŠ” ë°ì´í„°ë¥¼ ê¸°ë‹¤ë¦¬ë©° ì•½ 100ns ë™ì•ˆ ì•„ë¬´ê²ƒë„ í•˜ì§€ ëª»í•˜ê³  ë©ˆì¶¥ë‹ˆë‹¤(Stall). 7ë²ˆë§Œ ì í”„í•´ë„ 700nsê°€ ì‚¬ë¼ì§‘ë‹ˆë‹¤.

### 2.2. Cache Locality & Prefetching (ìŠ¹ë¦¬ ìš”ì¸)

ë°˜ë©´, **Ring Buffer**ê°€ ì••ë„ì ìœ¼ë¡œ ë¹ ë¥¸ ì´ìœ ëŠ” CPUì˜ **í•˜ë“œì›¨ì–´ í”„ë¦¬í˜ì²˜(Hardware Prefetcher)**ë¥¼ ì™„ë²½í•˜ê²Œ ë§Œì¡±ì‹œí‚¤ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

1. **Spatial Locality (ê³µê°„ ì§€ì—­ì„±):** ë°°ì—´ì€ ë°ì´í„°ê°€ ë¬¼ë¦¬ì ìœ¼ë¡œ ì—°ì†ë˜ì–´ ìˆìŠµë‹ˆë‹¤. CPUê°€ `index[0]`ì„ ìš”ì²­í•˜ë©´, ìºì‹œ ë¼ì¸(64byte) ë‹¨ìœ„ë¡œ `index[1]~[7]`ê¹Œì§€ ìë™ìœ¼ë¡œ L1 ìºì‹œì— ê°€ì ¸ì˜µë‹ˆë‹¤.
2. **Speculative Execution & Branch Prediction:** CPUëŠ” ë©”ëª¨ë¦¬ ì ‘ê·¼ íŒ¨í„´ì´ ë‹¨ìˆœí•œ ì„ í˜• ìˆœíšŒ(Linear Scan)ì„ì„ ê°ì§€í•˜ë©´, ëª…ë ¹ì´ ë–¨ì–´ì§€ê¸°ë„ ì „ì— ë¯¸ë¦¬ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤(Prefetching). ë˜í•œ, ë¶„ê¸°ê°€ ë»”í•œ ë°˜ë³µë¬¸ êµ¬ì¡° ë•ë¶„ì— CPU íŒŒì´í”„ë¼ì¸ì´ ë©ˆì¶”ì§€ ì•Šê³ (Pipeline Stall ìµœì†Œí™”) ëª…ë ¹ì–´ë¥¼ ìŸì•„ë¶€ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

> **Note on Benchmark Methodology:**
> ìœ„ 0.35nsë¼ëŠ” ìˆ˜ì¹˜ëŠ” `taskset`ì„ í†µí•´ ê²©ë¦¬ëœ(Isoalted) CPU ì½”ì–´ì—ì„œ, OSì˜ Context Switchingì„ ì°¨ë‹¨í•œ ìƒíƒœ(Core Pinning)ë¡œ ì¸¡ì •ëœ ê²°ê³¼ì…ë‹ˆë‹¤. ì¼ë°˜ì ì¸ ë°ìŠ¤í¬í†± í™˜ê²½ì—ì„œëŠ” OS ìŠ¤ì¼€ì¤„ëŸ¬ ê°„ì„­ìœ¼ë¡œ ì¸í•´ ì´ë³´ë‹¤ ë†’ì€ ìˆ˜ì¹˜ê°€ ë‚˜ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### 2.3. Small N Paradox ($100 \times L1 \ll 7 \times RAM$)

HFTì˜ í˜¸ê°€ì°½ì—ì„œ ì‹¤ì œ ì²´ê²°ì´ ë¹ˆë²ˆí•˜ê²Œ ì¼ì–´ë‚˜ëŠ” 'ì˜ë¯¸ìˆëŠ” ë²”ìœ„(Top of Book)'ëŠ” ë³´í†µ 50~100 ë ˆë²¨ ì´ë‚´ì…ë‹ˆë‹¤. $N$ì´ ì‘ì„ ë•Œ ì–´ë–¤ ì¼ì´ ë²Œì–´ì§ˆê¹Œìš”?

* **BTreeMap:** $\log N$ë²ˆì˜ ë¹„êµ + **7ë²ˆì˜ RAM ì ‘ê·¼ (Cache Miss)**
* **Ring Buffer:** $N$ë²ˆì˜ ë¹„êµ + **0ë²ˆì˜ RAM ì ‘ê·¼ (All L1 Cache Hit)**

ê²°ê³¼ì ìœ¼ë¡œ **100ë²ˆì˜ ì•„ì£¼ ë¹ ë¥¸ ì—°ì‚°(L1 Hit, 0.5ns)**ì´ **7ë²ˆì˜ ì•„ì£¼ ëŠë¦° ì—°ì‚°(RAM Miss, 100ns)**ë³´ë‹¤ í›¨ì”¬ ë¹ ë¦…ë‹ˆë‹¤. ì´ê²ƒì´ $O(N)$ì´ $O(\log N)$ì„ ì••ë„í•˜ëŠ” ìˆœê°„ì…ë‹ˆë‹¤.

---

## 3. ì•„í‚¤í…ì²˜ ì†”ë£¨ì…˜: Hybrid Architecture

ìš°ë¦¬ëŠ” ëª¨ë“  ë°ì´í„°ë¥¼ ë§ ë²„í¼ì— ë„£ì„ ìˆ˜ëŠ” ì—†ìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ìš©ë„ì— ë”°ë¼ ë©”ëª¨ë¦¬ ê³„ì¸µì„ ë¶„ë¦¬í•˜ëŠ” **"Hot/Cold Separation Strategy"**ë¥¼ ì±„íƒí–ˆìŠµë‹ˆë‹¤.

```mermaid
graph TD
    subgraph CPU["CPU Core"]
        Exec[Execution Engine]
    end

    subgraph L1["L1 Cache (32KB)"]
        Hot[("ğŸ”¥ Hot Path\nRing Buffer (Top 128 Levels)")]
    end

    subgraph RAM["Main Memory (DRAM)"]
        Cold[("â„ï¸ Cold Path\nHashMap / BTree (Deep Book)")]
    end

    Incoming[Order Event] --> Router{Price Check}
    Router -- "Inside Spread" --> Exec
    Exec <--> Hot
    
    Router -- "Deep OTM" --> Cold
    
    style Hot fill:#ff9900,stroke:#333,stroke-width:2px
    style Cold fill:#99ccff,stroke:#333,stroke-width:2px
    style L1 fill:#ffcccc,stroke:#f00,stroke-width:2px,stroke-dasharray: 5 5
```

> **Router Efficiency:** ë‹¤ì´ì–´ê·¸ë¨ì˜ `Router` ë‹¨ê³„ ë˜í•œ ë³µì¡í•œ ë¡œì§ì´ ì•„ë‹™ë‹ˆë‹¤. ë‹¨ìˆœíˆ `Order Price`ì™€ `Best Bid/Ask`ë¥¼ ë¹„êµí•˜ëŠ” ì •ìˆ˜ ì—°ì‚°(Integer Comparison)ìœ¼ë¡œ, ì´ ì—­ì‹œ L1 ìºì‹œ ë‚´ì—ì„œ ë‹¨ ëª‡ ì‚¬ì´í´ ë§Œì— ê²°ì •ë©ë‹ˆë‹¤.

### 3.1. L1 Hot Path (Ring Buffer)

* **ëŒ€ìƒ:** Best Bid/Askë¥¼ í¬í•¨í•œ Top 128 Price Levels.
* **íŠ¹ì§•:**
  * **Always in L1:** ì „ì²´ êµ¬ì¡°ì²´ì˜ í¬ê¸°ë¥¼ L1 ìºì‹œ ì‚¬ì´ì¦ˆ(32KB) ì´ë‚´ë¡œ ê°•ì œí•©ë‹ˆë‹¤ (e.g., `128 * Sizeof(OrderLevel) < 32KB`).
  * Snipping, Spread Capture ë“± ëª¨ë“  HFT ì „ëµì˜ 95%ê°€ ì´ êµ¬ê°„ì—ì„œ ì²˜ë¦¬ë©ë‹ˆë‹¤.
  * Rustì˜ `MaybeUninit`ì„ ì‚¬ìš©í•˜ì—¬ ì´ˆê¸°í™”(Zeroing) ì˜¤ë²„í—¤ë“œì¡°ì°¨ ì œê±°í•©ë‹ˆë‹¤.

### 3.2. Cold Path (Direct Indexing / HashMap)

* **ëŒ€ìƒ:** ì‹œì¥ê°€ ë²”ìœ„ë¥¼ ë²—ì–´ë‚œ ì§€ì •ê°€ ì£¼ë¬¸ë“¤ (Deep Book).
* **íŠ¹ì§•:**
  * ìš©ëŸ‰ì´ í¬ë¯€ë¡œ RAM ì‚¬ìš©ì´ ë¶ˆê°€í”¼í•©ë‹ˆë‹¤.
  * ì—¬ê¸°ì„œëŠ” ì†ë„ë³´ë‹¤ëŠ” **ìš©ëŸ‰(Capacity)**ê³¼ **ê´€ë¦¬ í¸ì˜ì„±**ì´ ìš°ì„ ìˆœìœ„ì…ë‹ˆë‹¤.

---

## 4. Rust êµ¬í˜„ ê°€ì´ë“œ (Implementation Keywords)

RustëŠ” ì´ëŸ¬í•œ Low-level ìµœì í™”ë¥¼ ì•ˆì „í•˜ê³  ëª…ì‹œì ìœ¼ë¡œ ìˆ˜í–‰í•  ìˆ˜ ìˆëŠ” ìµœê³ ì˜ ë„êµ¬ì…ë‹ˆë‹¤.

### Zero-Cost Abstractions

```rust
// ìºì‹œ ë¼ì¸(64byte) ì •ë ¬ì„ ê°•ì œí•˜ì—¬ False Sharing ë°©ì§€
#[repr(C, align(64))]
struct CacheAlignedOrderbook {
    // ...
}

// ì»´íŒŒì¼ íƒ€ì„ ìƒìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ëŸ°íƒ€ì„ ë°”ìš´ë“œ ì²´í¬ ì œê±° ê°€ëŠ¥ì„± ì—´ê¸°
struct RingBuffer<const N: usize> {
    buffer: [Order; N],
}
```

### Vectorization (SIMD)

ë‹¨ìˆœ `for` ë£¨í”„ ëŒ€ì‹  SIMDë¥¼ ì‚¬ìš©í•˜ì—¬ 16ê°œì˜ ê°€ê²© ë¹„êµë¥¼ ë‹¨ í•œ ë²ˆì˜ CPU ì‚¬ì´í´ì— ì²˜ë¦¬í•©ë‹ˆë‹¤.

```rust
#[cfg(target_arch = "x86_64")]
use std::arch::x86_64::*;

// AVX2ë¥¼ í™œìš©í•œ ë³‘ë ¬ ê°€ê²© ë¹„êµ
unsafe fn find_best_price_simd(prices: &[f64], target: f64) -> usize {
    // ... _mm256_cmp_pd ë“±ì˜ Intrinsic ì‚¬ìš©
}
```

### Memory Safety Bypass (Required for Speed)

HFTì—ì„œëŠ” ë°°ì—´ ê²½ê³„ ê²€ì‚¬(Bounds Check) ë¹„ìš©ì¡°ì°¨ ì‚¬ì¹˜ì…ë‹ˆë‹¤. ë¡œì§ì´ ì™„ë²½í•¨ì„ ì¦ëª…í–ˆë‹¤ë©´ `unsafe`ë¥¼ í†µí•´ ì¡±ì‡„ë¥¼ í’‰ë‹ˆë‹¤.

```rust
unsafe {
    // ìš°ë¦¬ëŠ” ì¸ë±ìŠ¤ê°€ Në³´ë‹¤ ì‘ìŒì„ ë³´ì¥í•œë‹¤.
    let order = self.buffer.get_unchecked(idx);
}
```

---

## 5. ê²°ë¡  ë° ì°¸ê³  ë¬¸í—Œ

ì„±ëŠ¥ ìµœì í™”ëŠ” ë‹¨ìˆœíˆ ì½”ë“œë¥¼ ì§§ê²Œ ì¤„ì´ëŠ” ê²ƒì´ ì•„ë‹™ë‹ˆë‹¤. **í•˜ë“œì›¨ì–´ì™€ì˜ ëŒ€í™”**ì…ë‹ˆë‹¤. ìš°ë¦¬ê°€ ì‘ì„±í•œ ì½”ë“œê°€ CPU íŒŒì´í”„ë¼ì¸ê³¼ ìºì‹œ ë©”ëª¨ë¦¬ ìœ„ì—ì„œ ì–´ë–»ê²Œ ì¶¤ì¶”ëŠ”ì§€ ì´í•´í•  ë•Œ, ë¹„ë¡œì†Œ ê·¹í•œì˜ ì„±ëŠ¥ì„ ëŒì–´ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**References:**

1. **Scott Meyers**: "Cpu Caches and Why You Care" (CppCon)
2. **Carl Cook**: "When a Microsecond Is an Eternity: C++ in High Frequency Trading" (CppCon)
3. **Martin Fowler**: "The LMAX Architecture"
4. **Rust Performance Book**
