---
public: true
title: 데이터 원본을 전체적으로 리드솔로몬 인코딩 후 샤드 분배 vs. 2. 스트라이핑 후 개별 블록 단위로 리드솔로몬 인코딩 후 샤드 분배 비교
date: '2025-12-27'
category: Distributed Systems
tags: [Distributed Systems]
excerpt: "---\n\n\U0001F539 1. 데이터 원본을 리드솔로몬 인코딩 후 노드마다 샤드를 나누는 방식\n\n  \n\n\U0001F6E0️ 개요\n\n• 원본 데이터를 한 번에 큰 단위로 리드솔로몬(Erasure Coding, EC) 인코딩을 수행한 뒤, 생성된 데이터 블록(원본)과 패리티..."
---

---

**🔹 1. 데이터 원본을 리드솔로몬 인코딩 후 노드마다 샤드를 나누는 방식**

  

**🛠️ 개요**

• 원본 데이터를 한 번에 큰 단위로 리드솔로몬(Erasure Coding, EC) 인코딩을 수행한 뒤, 생성된 **데이터 블록(원본)과 패리티 블록(복구용)을 여러 노드에 분배**하는 방식입니다.

• 예를 들어, **(6,3) Reed-Solomon 코드**를 사용하면, 원본 데이터를 6개로 나누고, 3개의 패리티 블록을 추가 생성하여 **총 9개 블록을 9개 노드에 분배**합니다.

  

**✅ 장점**

1. **쓰기 성능이 상대적으로 좋음**

• 원본 데이터를 한 번에 인코딩 후 분배하기 때문에, **추가적인 스트라이핑 연산이 필요 없음**.

• 네트워크 전송량이 예측 가능하고 일정함.

2. **복구 효율성이 높음 (특히 전체 노드 장애 시)**

• 데이터 블록과 패리티 블록이 일정한 방식으로 저장되므로, **특정 노드 손실 시 패리티 블록을 이용해 빠르게 재구성 가능**.

3. **CPU 오버헤드가 비교적 낮음**

• 리드솔로몬 인코딩을 한 번만 수행하면 되므로, CPU 연산량이 줄어듦.

  

**❌ 단점**

1. **데이터가 노드에 균등하게 저장되지 않을 수 있음**

• 하나의 원본 데이터를 여러 노드에 나누어 저장하기 때문에, **특정 노드가 자주 사용될 가능성**이 있음.

• 네트워크 트래픽이 특정 노드에 집중될 가능성이 있음.

2. **조각난 블록만 읽고 싶어도 전체 데이터의 일부를 복원해야 할 수도 있음**

• 작은 단위 데이터 접근 시에도, 원본 데이터가 인코딩된 상태이므로 **원본 블록을 직접 읽는 것이 어려울 수 있음**.

---

**🔹 2. 데이터를 스트라이핑한 후 개별 블록 단위로 리드솔로몬 인코딩 후 샤드 분배**

  

**🛠️ 개요**

• 원본 데이터를 일정 크기로 **스트라이핑(Striping)** 한 뒤, 각 블록 단위로 리드솔로몬 인코딩을 적용하여 샤드를 생성하고 분배하는 방식입니다.

• 예를 들어, 1GB 파일을 64MB 단위로 나누어 저장할 경우, 각각의 64MB 블록을 개별적으로 리드솔로몬 인코딩하여 분산 저장.

  

**✅ 장점**

1. **작은 단위 데이터 접근이 효율적**

• 특정 블록만 필요할 경우, 해당 블록만 읽고 패리티 블록을 활용하여 복구 가능.

• **Hadoop HDFS의 Erasure Coding 방식**이나 **MinIO의 Parity Striping** 방식에서 사용됨.

2. **노드 간 부하가 균등하게 분산됨**

• 데이터가 작은 단위로 쪼개져 분산되므로, **특정 노드에 트래픽이 집중되는 문제를 줄일 수 있음**.

3. **병렬 I/O 성능 향상**

• 여러 개의 작은 블록이 동시에 다른 노드에서 읽히므로, **대규모 분산 스토리지에서 높은 병렬성을 가질 수 있음**.

  

**❌ 단점**

1. **쓰기 성능이 낮을 수 있음**

• 데이터 단위마다 개별적으로 인코딩을 수행해야 하므로, CPU 연산량 증가 및 추가적인 네트워크 비용 발생.

• 네트워크에서 더 많은 작은 패킷이 이동해야 하므로, 지연(latency)이 증가할 가능성이 있음.

2. **복구 시 오버헤드 증가**

• 블록 단위로 분산되었기 때문에, 특정 노드에서 복구해야 할 블록이 많으면 복구 작업이 병목이 될 수 있음.

---

**🔹 최종 비교**

|**비교 항목**|**1. 원본 데이터 단위로 리드솔로몬 인코딩 후 샤드 분배**|**2. 스트라이핑 후 개별 블록 단위로 리드솔로몬 인코딩**|
|---|---|---|
|**쓰기 성능**|상대적으로 빠름 (한 번만 인코딩)|상대적으로 느림 (블록마다 개별 인코딩 필요)|
|**읽기 성능**|전체 데이터의 일부를 복구해야 할 수도 있음|특정 블록만 읽는 것이 가능|
|**복구 효율성**|전체 원본을 유지하기 쉬움|개별 블록 복구 시 오버헤드 증가 가능|
|**노드 부하**|일부 노드에 집중될 가능성이 있음|노드 간 부하가 균등하게 분배됨|
|**병렬 처리**|병렬성이 상대적으로 낮음|높은 병렬성 가능|

  

---

**🔹 결론: 어떤 방식이 더 적합할까?**

• **대용량 데이터 저장 & 읽기/쓰기 성능이 중요한 경우** → **1번 방식이 유리**

• Ceph RADOS Erasure Coding과 유사한 방식.

• 클러스터 전체의 안정성이 필요하고, 특정 파일을 전체적으로 다루는 경우 적합.

• **데이터 조각 단위로 접근이 많고, 병렬성이 중요한 경우** → **2번 방식이 유리**

• Hadoop HDFS의 EC, MinIO의 스트라이핑 방식과 유사.

• 개별적인 작은 파일이나 블록 단위의 병렬 처리가 중요한 경우 적합.

  

**즉, “1번은 전체 데이터 중심의 안정성을 강조하고, 2번은 개별 블록 접근성과 병렬성을 강조하는 방식”**이라고 볼 수 있습니다. 🚀

  

혹시 더 구체적으로 비교할 부분이 있다면 알려주세요! 😊
