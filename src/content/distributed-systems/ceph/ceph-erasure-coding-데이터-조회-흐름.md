---
public: true
title: Ceph Erasure Coding 데이터 조회 흐름
date: '2025-12-27'
category: Distributed Systems
tags: []
excerpt: |-
  Ceph Erasure Coding 데이터 조회 흐름

   1. 클라이언트 요청 단계
  1. 객체 접근 요청: 클라이언트가 특정 객체 ID로 데이터 요청
  2. CRUSH 계산: 클라이언트는 CRUSH 알고리즘을 사용해 객체의 청크들이 저장된 OSD...
---

# Ceph Erasure Coding 데이터 조회 흐름

## 1. 클라이언트 요청 단계
1. **객체 접근 요청**: 클라이언트가 특정 객체 ID로 데이터 요청
2. **CRUSH 계산**: 클라이언트는 CRUSH 알고리즘을 사용해 객체의 청크들이 저장된 OSD 위치 계산
3. **PG(Placement Group) 결정**: 객체가 속한 배치 그룹 식별

## 2. 데이터 청크 수집 단계
1. **가용 청크 확인**: 
   - 모든 데이터 청크(K개)가 가용한 경우: 직접 데이터 청크만 읽음
   - 일부 데이터 청크 누락: 복구를 위한 최소 청크 세트 결정

2. **최적 청크 선택**:
   ```cpp
   minimum_to_decode_with_cost(want_to_read, available, &minimum);
   ```
   - `want_to_read`: 필요한 청크 ID 집합
   - `available`: 가용한 청크와 접근 비용 맵
   - `minimum`: 최소 비용으로 복구 가능한 청크 집합

3. **청크 병렬 요청**: 필요한 모든 청크를 병렬로 요청 (데이터 청크 + 필요한 코딩 청크)

## 3. 데이터 복원 단계
1. **모든 데이터 청크 가용 시**: 
   - 단순히 필요한 데이터 청크를 연결하여 원본 데이터 구성
   - 예: K=4인 경우, 4개 데이터 청크 연결

2. **일부 데이터 청크 누락 시**:
   - `decode()` 메서드 호출로 복원 시작
   ```cpp
   decode(want_to_read, chunks, &decoded, chunk_size);
   ```

3. **복호화 과정**:
   - 이레이저 코딩 알고리즘 사용하여 누락된 청크 복원
   - 각 구현별 복호화 방식 차이:
     - **Jerasure**: Reed-Solomon 기반 행렬 연산으로 복원
     - **LRC**: 로컬/글로벌 패리티 활용 복원
     - **ISA**: Intel ISA-L 최적화 라이브러리 사용
     - **CLAY**: 계층적 복원 방식

4. **하위 청크(Sub-chunk) 처리**:
   - 일부 구현은 청크를 더 작은 하위 청크로 분할
   - 필요한 하위 청크만 복원하여 효율성 증가

## 4. 응답 처리 단계
1. **데이터 재구성**:
   - 복원된 청크들에서 요청된 데이터 부분 추출
   - 청크 오프셋 계산: `byte_offset = B % chunk_size`
   - 청크 인덱스 계산: `chunk_index = B / chunk_size`

2. **버퍼 생성 및 반환**:
   - 복원된 데이터를 단일 버퍼로 연결
   - 패딩 제거 (마지막 청크에 추가된 패딩)
   ```cpp
   decode_concat(want_to_read, chunks, &decoded);
   ```

3. **클라이언트 응답**:
   - 재구성된 원본 데이터를 클라이언트에 반환

## 5. 청크 캐싱 및 최적화
1. **읽기 캐싱**: 자주 접근하는 청크는 메모리에 캐싱
2. **부분 읽기**: 필요한 부분만 복원 (전체 객체가 필요 없는 경우)
3. **지연 복구**: 읽기 요청이 없는 손실 청크는 즉시 복구하지 않고 지연

## 성능 고려사항
1. **복구 비용**: M(코딩 청크 수)이 클수록 저장 효율성 증가, 복구 비용 증가
2. **네트워크 트래픽**: 복구 시 필요한 데이터 전송량 (특히 CLAY 알고리즘에서 최적화)
3. **디코딩 계산 비용**: 알고리즘별 CPU 사용량과 지연 시간 차이
